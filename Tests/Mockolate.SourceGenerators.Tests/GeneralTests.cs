using System.Collections.Generic;
using System.Net.Http;
using System.Threading;

namespace Mockolate.SourceGenerators.Tests;

public class GeneralTests
{
	[Fact]
	public async Task AllGeneratedSourcesShouldContainAutoGeneratedTag()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System;
			     using System.Threading;
			     using System.Threading.Tasks;
			     using Mockolate;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var y = Mock.Create<IMyInterface>();
			     			var z = Mock.Create<MyBaseClass>();
			             }
			         }

			         public interface IMyInterface
			         {
			             void MyMethod(int v1, bool v2, double v3, long v4, uint v5, string v6, DateTime v7);
			         }

			         public class MyBaseClass
			         {
			             protected virtual Task<int> MyMethod(int v1, bool v2, double v3, long v4, uint v5, string v6, DateTime v7, TimeSpan v8, CancellationToken v9)
			             {
			                 return Task.FromResult(1);
			             }
			         }
			     }
			     """, typeof(DateTime), typeof(Task), typeof(CancellationToken));

		await That(result.Diagnostics).IsEmpty();

		await That(result.Sources).HasCount().AtLeast(9);
		await That(result.Sources.Values).All()
			.Satisfy(x => x!.Contains("<auto-generated>") && x.Contains("</auto-generated>"));
	}

	[Fact]
	public async Task MockOfHttpMessageHandler_ShouldContainGetEnumeratorFromIEnumerableAndIEnumerableOfT()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Net.Http;
			     using Mockolate;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var mock = Mock.Create<HttpMessageHandler>();
			     			var httpClient = new HttpClient(mock);
			             }
			         }
			     }
			     """, typeof(HttpMessageHandler));

		await That(result.Diagnostics).IsEmpty();

		await That(result.Sources).ContainsKey("MockForHttpMessageHandler.g.cs").WhoseValue
			.Contains("protected override void Dispose(bool disposing)").And
			.DoesNotContain("void Dispose()");
	}

	[Fact]
	public async Task MockOfIList_ShouldContainGetEnumeratorFromIEnumerableAndIEnumerableOfT()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IList<int>>();
			             }
			         }
			     }

			     """, typeof(IList<>));

		await That(result.Diagnostics).IsEmpty();

		await That(result.Sources).ContainsKey("MockForIListint.g.cs").WhoseValue
			.Contains("System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()").And
			.Contains("public System.Collections.Generic.IEnumerator<int> GetEnumerator()");
	}

	[Fact]
	public async Task MockOfIList_ShouldIncludeFullNameAsGenericParameter()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IList<MyOtherCode.MyRecord>>();
			             }
			         }
			     }

			     namespace MyOtherCode
			     {
			         public record MyRecord(int Id, string Name);
			     }

			     """, typeof(IList<>));

		await That(result.Diagnostics).IsEmpty();

		await That(result.Sources).ContainsKey("MockForIListMyRecord.g.cs").WhoseValue
			.Contains("internal class MockForIListMyRecord : System.Collections.Generic.IList<MyOtherCode.MyRecord>");
	}

	[Fact]
	public async Task SameMethodInMultipleInterfaces_ShouldUseExplicitImplementation()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IMyInterface1, IMyInterface2>();
			             }
			         }

			         public interface IMyInterface1
			         {
			             void MyMethod(int v1);
			         }

			         public interface IMyInterface2
			         {
			             void MyMethod(int v1);
			         }
			     }

			     """, typeof(IList<>));

		await That(result.Diagnostics).IsEmpty();

		await That(result.Sources).ContainsKey("MockForIMyInterface1_IMyInterface2.g.cs").WhoseValue
			.Contains("public void MyMethod(int v1)").And
			.Contains("void MyCode.IMyInterface2.MyMethod(int v1)");
	}

	[Fact]
	public async Task SameMethodInNestedInterfaces_ShouldUseExplicitImplementation()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IMyInterface1>();
			             }
			         }

			         public interface IMyInterface1 : IMyInterface2
			         {
			             new void MyMethod(int v1);
			         }

			         public interface IMyInterface2
			         {
			             void MyMethod(int v1);
			         }
			     }

			     """, typeof(IList<>));

		await That(result.Diagnostics).IsEmpty();

		await That(result.Sources).ContainsKey("MockForIMyInterface1.g.cs").WhoseValue
			.Contains("public void MyMethod(int v1)").And
			.Contains("void MyCode.IMyInterface2.MyMethod(int v1)");
	}

	[Fact]
	public async Task InterfaceProperty_ShouldRecursivelyCreateMocks()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IMyInterface1>();
			             }
			         }

			         public interface IMyInterface1
			         {
			             IMyInterface2 MyProperty { get; }
			         }
			     
			         public interface IMyInterface2
			         {
			             IMyInterface3 MyMethod(int v1);
			         }
			     
			         public interface IMyInterface3
			         {
			             IMyInterface1 MyInnerMethod(int v1);
			         }
			     }

			     """, typeof(IList<>));

		await That(result.Diagnostics).IsEmpty();

		await That(result.Sources)
			.ContainsKey("MockForIMyInterface1.g.cs").And
			.ContainsKey("MockForIMyInterface2.g.cs").And
			.ContainsKey("MockForIMyInterface3.g.cs");
	}
}
