using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics.CodeAnalysis;
using System.Net.Http;
using System.Threading;

namespace Mockolate.SourceGenerators.Tests;

public class GeneralTests
{
	[Fact]
	public async Task AllGeneratedSourcesShouldContainAutoGeneratedTag()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System;
			     using System.Threading;
			     using System.Threading.Tasks;
			     using Mockolate;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var y = Mock.Create<IMyInterface>();
			     			var z = Mock.Create<MyBaseClass>();
			             }
			         }

			         public interface IMyInterface
			         {
			             void MyMethod(int v1, bool v2, double v3, long v4, uint v5, string v6, DateTime v7);
			         }

			         public class MyBaseClass
			         {
			             protected virtual Task<int> MyMethod(int v1, bool v2, double v3, long v4, uint v5, string v6, DateTime v7, TimeSpan v8, CancellationToken v9)
			             {
			                 return Task.FromResult(1);
			             }
			         }
			     }
			     """, typeof(DateTime), typeof(Task), typeof(CancellationToken));

		await That(result.Sources).HasCount().AtLeast(9);
		await That(result.Sources.Values).All()
			.Satisfy(x => x!.Contains("<auto-generated>") && x.Contains("</auto-generated>"));

		await That(result.Diagnostics).IsEmpty();
	}

	[Fact]
	public async Task InterfaceProperty_ShouldRecursivelyCreateMocks()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IMyInterface1>();
			             }
			         }

			         public interface IMyInterface1
			         {
			             IMyInterface2 MyProperty { get; }
			         }

			         public interface IMyInterface2
			         {
			             IMyInterface3 MyMethod(int v1);
			         }

			         public interface IMyInterface3
			         {
			             IMyInterface1 MyInnerMethod(int v1);
			         }
			     }

			     """, typeof(IList<>));

		await That(result.Diagnostics).IsEmpty();

		await That(result.Sources)
			.ContainsKey("MockForIMyInterface1.g.cs").And
			.ContainsKey("MockForIMyInterface2.g.cs").And
			.ContainsKey("MockForIMyInterface3.g.cs");
	}

	[Fact]
	public async Task MockOfHttpMessageHandler_ShouldContainGetEnumeratorFromIEnumerableAndIEnumerableOfT()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Net.Http;
			     using Mockolate;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var mock = Mock.Create<HttpMessageHandler>();
			     			var httpClient = new HttpClient(mock);
			             }
			         }
			     }
			     """, typeof(HttpMessageHandler));

		await That(result.Sources).ContainsKey("MockForHttpMessageHandler.g.cs").WhoseValue
			.Contains("protected override void Dispose(bool disposing)").And
			.DoesNotContain("void Dispose()");

		await That(result.Diagnostics).IsEmpty();
	}

	[Fact]
	public async Task MockOfIList_ShouldContainGetEnumeratorFromIEnumerableAndIEnumerableOfT()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IList<int>>();
			             }
			         }
			     }

			     """, typeof(IList<>));

		await That(result.Sources).ContainsKey("MockForIListint.g.cs").WhoseValue
			.Contains("System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()").And
			.Contains("public System.Collections.Generic.IEnumerator<int> GetEnumerator()");
	}

	[Fact]
	public async Task MockOfIList_ShouldIncludeFullNameAsGenericParameter()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IList<MyOtherCode.MyRecord>>();
			             }
			         }
			     }

			     namespace MyOtherCode
			     {
			         public record MyRecord(int Id, string Name);
			     }

			     """, typeof(IList<>));

		await That(result.Sources).ContainsKey("MockForIListMyRecord.g.cs").WhoseValue
			.Contains("internal class MockForIListMyRecord : System.Collections.Generic.IList<MyOtherCode.MyRecord>");
	}

	[Fact]
	public async Task MultipleInterfacesWithSameName_ShouldAddSuffixToSetupAndVerifyMethods()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IMyInterface, MyCode.N1.IMyInterface, MyCode.N2.IMyInterface>();
			             }
			         }

			         public interface IMyInterface
			         {
			             void MyMethod(int v1);
			         }
			     }

			     namespace MyCode.N1
			     {
			         public interface IMyInterface
			         {
			             void MyMethod(int v1);
			         }
			     }

			     namespace MyCode.N2
			     {
			         public interface IMyInterface
			         {
			             void MyMethod(int v1);
			         }
			     }

			     """, typeof(IList<>));

		await That(result.Diagnostics).IsEmpty();

		await That(result.Sources).ContainsKey("MockForIMyInterface_IMyInterface_IMyInterfaceExtensions.g.cs")
			.WhoseValue
			.Contains("public IMockSetup<MyCode.N2.IMyInterface> SetupIMyInterface__2Mock");
	}

	[Fact]
	public async Task ObsoleteAttributes_ShouldBeRepeatedInMock()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System;
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<MyBaseClass>();
			             }
			         }

			         public class MyBaseClass
			         {
			              [Obsolete()]
			              public MyBaseClass()
			              {
			                 SomeProperty = 1;
			              }
			              
			              [Obsolete("This constructor is obsolete")]
			              public MyBaseClass(int value)
			              {
			                 SomeProperty = value;
			              }
			              
			              [Obsolete("This event is obsolete")]
			              public virtual event EventHandler<int> SomeEvent;
			              
			              [Obsolete("This property is obsolete")]
			              public virtual int SomeProperty { get; }
			              
			              [Obsolete("This method is obsolete")]
			              public virtual int SomeMethod()
			              {
			                SomeEvent?.Invoke(this, SomeProperty);
			                return 3;
			              }
			              
			              [Obsolete("This indexer is obsolete")]
			              public virtual int this[int index] => 4;
			         }
			     }

			     """, typeof(ObsoleteAttribute));

		await That(result.Sources)
			.ContainsKey("MockForMyBaseClass.g.cs").WhoseValue
			.Contains("""
			          	[System.Obsolete]
			          	public MockForMyBaseClass(MockRegistration mockRegistration)
			          """).IgnoringNewlineStyle().And
			.Contains("""
			          	[System.Obsolete("This constructor is obsolete")]
			          	public MockForMyBaseClass(int value, MockRegistration mockRegistration)
			          """).IgnoringNewlineStyle().And
			.Contains("""
			          	[System.Obsolete("This event is obsolete")]
			          	public override event System.EventHandler<int>? SomeEvent
			          """).IgnoringNewlineStyle().And
			.Contains("""
			          	[System.Obsolete("This property is obsolete")]
			          	public override int SomeProperty
			          """).IgnoringNewlineStyle().And
			.Contains("""
			          	[System.Obsolete("This indexer is obsolete")]
			          	public override int this[int index]
			          """).IgnoringNewlineStyle().And
			.Contains("""
			          	[System.Obsolete("This method is obsolete")]
			          	public override int SomeMethod()
			          """).IgnoringNewlineStyle();
	}

	[Fact]
	public async Task SameMethodInMultipleInterfaces_ShouldUseExplicitImplementation()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IMyInterface1, IMyInterface2>();
			             }
			         }

			         public interface IMyInterface1
			         {
			             void MyMethod(int v1);
			         }

			         public interface IMyInterface2
			         {
			             void MyMethod(int v1);
			         }
			     }

			     """, typeof(IList<>));

		await That(result.Diagnostics).IsEmpty();

		await That(result.Sources).ContainsKey("MockForIMyInterface1_IMyInterface2.g.cs").WhoseValue
			.Contains("public void MyMethod(int v1)").And
			.Contains("void MyCode.IMyInterface2.MyMethod(int v1)");
	}

	[Fact]
	public async Task SameMethodInNestedInterfaces_ShouldUseExplicitImplementation()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IMyInterface1>();
			             }
			         }

			         public interface IMyInterface1 : IMyInterface2
			         {
			             new void MyMethod(int v1);
			         }

			         public interface IMyInterface2
			         {
			             void MyMethod(int v1);
			         }
			     }

			     """, typeof(IList<>));

		await That(result.Diagnostics).IsEmpty();

		await That(result.Sources).ContainsKey("MockForIMyInterface1.g.cs").WhoseValue
			.Contains("public void MyMethod(int v1)").And
			.Contains("void MyCode.IMyInterface2.MyMethod(int v1)");
	}

	[Fact]
	public async Task WithAttributes_ShouldAddAttributesToGeneratedCode()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System;
			     using System.ComponentModel;
			     using System.Diagnostics.CodeAnalysis;
			     using System.Data;
			     using Mockolate;

			     namespace MyCode;
			     public class Program
			     {
			         public static void Main(string[] args)
			         {
			     		_ = Mock.Create<IMyService>();
			         }
			     }

			     public interface IMyService
			     {
			         [AllowNull]
			         string SomeProperty { get; set; }
			         [Localizable(false)]
			         string MyMethod(string message);
			         [CustomAttribute(
			             true,
			             (byte)42,
			             'X',
			             3.14,
			             2.71f,
			             100,
			             999L,
			             (sbyte)-10,
			             (short)500,
			             "test",
			             123u,
			             456ul,
			             (ushort)789,
			             typeof(string),
			             MyEnum.Value2,
			             new int[] { 1, 2, 3 },
			             BoolParam = false,
			             ByteParam = (byte)99,
			             CharParam = 'Y',
			             DoubleParam = 1.23,
			             FloatParam = 4.56f,
			             IntParam = 200,
			             LongParam = 888L,
			             SByteParam = (sbyte)-5,
			             ShortParam = (short)300,
			             StringParam = "named",
			             UIntParam = 111u,
			             ULongParam = 222ul,
			             UShortParam = (ushort)333,
			             ObjectParam = 42,
			             TypeParam = typeof(int),
			             EnumParam = MyFlagEnum.Value1 | MyFlagEnum.Value2,
			             ArrayParam = new string[] { "a", "b" }
			         )]
			         event EventHandler<int> MyEvent;
			     }

			     public enum MyEnum
			     {
			         Value1 = 1,
			         Value2 = 2
			     }

			     [Flags]
			     public enum MyFlagEnum
			     {
			         Value1 = 1,
			         Value2 = 2
			     }

			     [AttributeUsage(AttributeTargets.All)]
			     public class CustomAttribute : Attribute
			     {
			         public CustomAttribute(
			             bool boolArg,
			             byte byteArg,
			             char charArg,
			             double doubleArg,
			             float floatArg,
			             int intArg,
			             long longArg,
			             sbyte sbyteArg,
			             short shortArg,
			             string stringArg,
			             uint uintArg,
			             ulong ulongArg,
			             ushort ushortArg,
			             Type typeArg,
			             MyEnum enumArg,
			             int[] arrayArg)
			         {
			         }

			         public bool BoolParam { get; set; }
			         public byte ByteParam { get; set; }
			         public char CharParam { get; set; }
			         public double DoubleParam { get; set; }
			         public float FloatParam { get; set; }
			         public int IntParam { get; set; }
			         public long LongParam { get; set; }
			         public sbyte SByteParam { get; set; }
			         public short ShortParam { get; set; }
			         public string StringParam { get; set; }
			         public uint UIntParam { get; set; }
			         public ulong ULongParam { get; set; }
			         public ushort UShortParam { get; set; }
			         public object ObjectParam { get; set; }
			         public Type TypeParam { get; set; }
			         public MyFlagEnum EnumParam { get; set; }
			         public string[] ArrayParam { get; set; }
			     }
			     """, typeof(AllowNullAttribute), typeof(IDataParameter), typeof(LocalizableAttribute),
				typeof(AttributeUsageAttribute));

		await That(result.Sources).ContainsKey("MockForIMyService.g.cs").WhoseValue
			.Contains("""
			          	/// <inheritdoc cref="MyCode.IMyService.SomeProperty" />
			          	[System.Diagnostics.CodeAnalysis.AllowNull]
			          	public string SomeProperty
			          	{
			          		get
			          		{
			          			return MockRegistrations.GetProperty<string>("MyCode.IMyService.SomeProperty", () => MockRegistrations.Behavior.DefaultValue.Generate(default(string)!), this._wrapped is null ? null : () => this._wrapped.SomeProperty);
			          		}
			          		set
			          		{
			          			MockRegistrations.SetProperty("MyCode.IMyService.SomeProperty", value);
			          			if (this._wrapped is not null)
			          			{
			          				this._wrapped.SomeProperty = value;
			          			}
			          		}
			          	}
			          """).IgnoringNewlineStyle().And
			.Contains("""
			          	/// <inheritdoc cref="MyCode.IMyService.MyMethod(string)" />
			          	[System.ComponentModel.Localizable(false)]
			          	public string MyMethod(string message)
			          	{
			          		MethodSetupResult<string> methodExecution = MockRegistrations.InvokeMethod<string>("MyCode.IMyService.MyMethod", p => MockRegistrations.Behavior.DefaultValue.Generate(default(string)!, p), message);
			          		if (this._wrapped is not null)
			          		{
			          			var baseResult = this._wrapped.MyMethod(message);
			          			if (!methodExecution.HasSetupResult)
			          			{
			          				methodExecution.TriggerCallbacks(message);
			          				return baseResult;
			          			}
			          		}
			          		methodExecution.TriggerCallbacks(message);
			          		return methodExecution.Result;
			          	}
			          """).IgnoringNewlineStyle().And
			.Contains("""
			          	/// <inheritdoc cref="MyCode.IMyService.MyEvent" />
			          	[MyCode.Custom(true, (byte)42, 'X', 3.14, 2.71F, 100, 999L, (sbyte)-10, (short)500, "test", 123u, 456uL, (ushort)789, typeof(string), (MyCode.MyEnum)2, new int[]{1, 2, 3}, BoolParam = false, ByteParam = (byte)99, CharParam = 'Y', DoubleParam = 1.23, FloatParam = 4.56F, IntParam = 200, LongParam = 888L, SByteParam = (sbyte)-5, ShortParam = (short)300, StringParam = "named", UIntParam = 111u, ULongParam = 222uL, UShortParam = (ushort)333, ObjectParam = 42, TypeParam = typeof(int), EnumParam = (MyCode.MyFlagEnum)3, ArrayParam = new string[]{"a", "b"})]
			          	public event System.EventHandler<int>? MyEvent
			          	{
			          		add
			          		{
			          			MockRegistrations.AddEvent("MyCode.IMyService.MyEvent", value?.Target, value?.Method);
			          			if (this._wrapped is not null)
			          			{
			          				this._wrapped.MyEvent += value;
			          			}
			          		}
			          		remove
			          		{
			          			MockRegistrations.RemoveEvent("MyCode.IMyService.MyEvent", value?.Target, value?.Method);
			          			if (this._wrapped is not null)
			          			{
			          				this._wrapped.MyEvent -= value;
			          			}
			          		}
			          	}
			          """).IgnoringNewlineStyle();
	}
}
