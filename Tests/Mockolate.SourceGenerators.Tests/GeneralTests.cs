using System.Collections.Generic;
using System.Data;
using System.Diagnostics.CodeAnalysis;
using System.Net.Http;
using System.Threading;

namespace Mockolate.SourceGenerators.Tests;

public class GeneralTests
{
	[Fact]
	public async Task AllGeneratedSourcesShouldContainAutoGeneratedTag()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System;
			     using System.Threading;
			     using System.Threading.Tasks;
			     using Mockolate;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var y = Mock.Create<IMyInterface>();
			     			var z = Mock.Create<MyBaseClass>();
			             }
			         }

			         public interface IMyInterface
			         {
			             void MyMethod(int v1, bool v2, double v3, long v4, uint v5, string v6, DateTime v7);
			         }

			         public class MyBaseClass
			         {
			             protected virtual Task<int> MyMethod(int v1, bool v2, double v3, long v4, uint v5, string v6, DateTime v7, TimeSpan v8, CancellationToken v9)
			             {
			                 return Task.FromResult(1);
			             }
			         }
			     }
			     """, typeof(DateTime), typeof(Task), typeof(CancellationToken));

		await That(result.Sources).HasCount().AtLeast(9);
		await That(result.Sources.Values).All()
			.Satisfy(x => x!.Contains("<auto-generated>") && x.Contains("</auto-generated>"));

		await That(result.Diagnostics).IsEmpty();
	}

	[Fact]
	public async Task InterfaceProperty_ShouldRecursivelyCreateMocks()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IMyInterface1>();
			             }
			         }

			         public interface IMyInterface1
			         {
			             IMyInterface2 MyProperty { get; }
			         }

			         public interface IMyInterface2
			         {
			             IMyInterface3 MyMethod(int v1);
			         }

			         public interface IMyInterface3
			         {
			             IMyInterface1 MyInnerMethod(int v1);
			         }
			     }

			     """, typeof(IList<>));

		await That(result.Diagnostics).IsEmpty();

		await That(result.Sources)
			.ContainsKey("MockForIMyInterface1.g.cs").And
			.ContainsKey("MockForIMyInterface2.g.cs").And
			.ContainsKey("MockForIMyInterface3.g.cs");
	}

	[Fact]
	public async Task MockOfHttpMessageHandler_ShouldContainGetEnumeratorFromIEnumerableAndIEnumerableOfT()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Net.Http;
			     using Mockolate;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var mock = Mock.Create<HttpMessageHandler>();
			     			var httpClient = new HttpClient(mock);
			             }
			         }
			     }
			     """, typeof(HttpMessageHandler));

		await That(result.Sources).ContainsKey("MockForHttpMessageHandler.g.cs").WhoseValue
			.Contains("protected override void Dispose(bool disposing)").And
			.DoesNotContain("void Dispose()");

		await That(result.Diagnostics).IsEmpty();
	}

	[Fact]
	public async Task MockOfIList_ShouldContainGetEnumeratorFromIEnumerableAndIEnumerableOfT()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IList<int>>();
			             }
			         }
			     }

			     """, typeof(IList<>));

		await That(result.Sources).ContainsKey("MockForIListint.g.cs").WhoseValue
			.Contains("System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()").And
			.Contains("public System.Collections.Generic.IEnumerator<int> GetEnumerator()");
	}

	[Fact]
	public async Task MockOfIList_ShouldIncludeFullNameAsGenericParameter()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IList<MyOtherCode.MyRecord>>();
			             }
			         }
			     }

			     namespace MyOtherCode
			     {
			         public record MyRecord(int Id, string Name);
			     }

			     """, typeof(IList<>));

		await That(result.Sources).ContainsKey("MockForIListMyRecord.g.cs").WhoseValue
			.Contains("internal class MockForIListMyRecord : System.Collections.Generic.IList<MyOtherCode.MyRecord>");
	}

	[Fact]
	public async Task ObsoleteAttributes_ShouldBeRepeatedInMock()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System;
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<MyBaseClass>();
			             }
			         }

			         public class MyBaseClass
			         {
			              [Obsolete()]
			              public MyBaseClass()
			              {
			                 SomeProperty = 1;
			              }
			              
			              [Obsolete("This constructor is obsolete")]
			              public MyBaseClass(int value)
			              {
			                 SomeProperty = value;
			              }
			              
			              [Obsolete("This event is obsolete")]
			              public virtual event EventHandler<int> SomeEvent;
			              
			              [Obsolete("This property is obsolete")]
			              public virtual int SomeProperty { get; }
			              
			              [Obsolete("This method is obsolete")]
			              public virtual int SomeMethod()
			              {
			                SomeEvent?.Invoke(this, SomeProperty);
			                return 3;
			              }
			              
			              [Obsolete("This indexer is obsolete")]
			              public virtual int this[int index] => 4;
			         }
			     }

			     """, typeof(ObsoleteAttribute));

		await That(result.Sources)
			.ContainsKey("MockForMyBaseClass.g.cs").WhoseValue
			.Contains("""
			          	[System.Obsolete]
			          	public MockForMyBaseClass(MockRegistration mockRegistration)
			          """).IgnoringNewlineStyle().And
			.Contains("""
			          	[System.Obsolete("This constructor is obsolete")]
			          	public MockForMyBaseClass(int value, MockRegistration mockRegistration)
			          """).IgnoringNewlineStyle().And
			.Contains("""
			          	[System.Obsolete("This event is obsolete")]
			          	public override event System.EventHandler<int>? SomeEvent
			          """).IgnoringNewlineStyle().And
			.Contains("""
			          	[System.Obsolete("This property is obsolete")]
			          	public override int SomeProperty
			          """).IgnoringNewlineStyle().And
			.Contains("""
			          	[System.Obsolete("This indexer is obsolete")]
			          	public override int this[int index]
			          """).IgnoringNewlineStyle().And
			.Contains("""
			          	[System.Obsolete("This method is obsolete")]
			          	public override int SomeMethod()
			          """).IgnoringNewlineStyle();
	}

	[Fact]
	public async Task SameMethodInMultipleInterfaces_ShouldUseExplicitImplementation()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IMyInterface1, IMyInterface2>();
			             }
			         }

			         public interface IMyInterface1
			         {
			             void MyMethod(int v1);
			         }

			         public interface IMyInterface2
			         {
			             void MyMethod(int v1);
			         }
			     }

			     """, typeof(IList<>));

		await That(result.Diagnostics).IsEmpty();

		await That(result.Sources).ContainsKey("MockForIMyInterface1_IMyInterface2.g.cs").WhoseValue
			.Contains("public void MyMethod(int v1)").And
			.Contains("void MyCode.IMyInterface2.MyMethod(int v1)");
	}

	[Fact]
	public async Task SameMethodInNestedInterfaces_ShouldUseExplicitImplementation()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System.Collections.Generic;

			     namespace MyCode
			     {
			         public class Program
			         {
			             public static void Main(string[] args)
			             {
			     			var x = Mockolate.Mock.Create<IMyInterface1>();
			             }
			         }

			         public interface IMyInterface1 : IMyInterface2
			         {
			             new void MyMethod(int v1);
			         }

			         public interface IMyInterface2
			         {
			             void MyMethod(int v1);
			         }
			     }

			     """, typeof(IList<>));

		await That(result.Diagnostics).IsEmpty();

		await That(result.Sources).ContainsKey("MockForIMyInterface1.g.cs").WhoseValue
			.Contains("public void MyMethod(int v1)").And
			.Contains("void MyCode.IMyInterface2.MyMethod(int v1)");
	}

	[Fact]
	public async Task WithAllowNullAttribute_ShouldAddAttributeToGeneratedCode()
	{
		GeneratorResult result = Generator
			.Run("""
			     using System;
			     using System.Diagnostics.CodeAnalysis;
			     using System.Data;
			     using Mockolate;

			     namespace MyCode;
			     public class Program
			     {
			         public static void Main(string[] args)
			         {
			     		_ = Mock.Create<IMyService>();
			         }
			     }

			     public interface IMyService
			     {
			         [AllowNull]
			         string SomeProperty { get; set; }
			     }
			     """, typeof(AllowNullAttribute), typeof(IDataParameter));

		await That(result.Sources).ContainsKey("MockForIMyService.g.cs").WhoseValue
			.Contains("""
			          	/// <inheritdoc cref="MyCode.IMyService.SomeProperty" />
			          	[System.Diagnostics.CodeAnalysis.AllowNull]
			          	public string SomeProperty
			          	{
			          		get
			          		{
			          			return MockRegistrations.GetProperty<string>("MyCode.IMyService.SomeProperty");
			          		}
			          		set
			          		{
			          			MockRegistrations.SetProperty("MyCode.IMyService.SomeProperty", value);
			          		}
			          	}
			          """).IgnoringNewlineStyle();
	}
}
