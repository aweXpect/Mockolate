using System.Text;
using Microsoft.CodeAnalysis;

namespace Mockolate.SourceGenerators.Sources;

#pragma warning disable S3776 // Cognitive Complexity of methods should not be too high
internal static partial class Sources
{
	private static StringBuilder InitializeBuilder(string[] namespaces)
	{
		StringBuilder sb = new();
		sb.AppendLine("""
		              //----------------------
		              // <auto-generated>
		              //     This code was generated by the Mockolate source generator.
		              //
		              //     Changes to this file may cause incorrect behavior and
		              //     will be lost if the code is regenerated!
		              // </auto-generated>
		              //----------------------
		              """);
		sb.AppendLine();
		foreach (string @namespace in namespaces)
		{
			sb.Append("using ").Append(@namespace).AppendLine(";");
		}

		sb.AppendLine();
		return sb;
	}

	/// <summary>
	///     Creates the static <c>Mock</c> class with the <c>Create</c> methods to create new mocks.
	/// </summary>
	public static string MockClass()
	{
		StringBuilder sb = InitializeBuilder([
			"System",
			"Mockolate.Exceptions",
			"Mockolate.Setup",
		]);

		int maxNumberOfArguments = 9;
		sb.AppendLine("""
		              namespace Mockolate;

		              #nullable enable
		              /// <summary>
		              ///     Create new mocks by calling <c>Mock.Create&lt;T&gt;()</c>.<br />
		              ///     You can specify up to eight additional interfaces that the mock will also implement.
		              /// </summary>
		              /// <remarks>
		              ///     If your type is a class without default constructor, you can provide constructor parameters using <see cref="BaseClass.WithConstructorParameters(object?[])" />.
		              ///     You can also provide a <see cref="MockBehavior"/> parameter to customize how the mock should behave in certain scenarios.
		              /// </remarks>
		              internal static partial class Mock
		              {
		              """);
		sb.AppendLine("""
		              /// <summary>
		              ///     Create a new mock for <typeparamref name="T" /> with the default <see cref="MockBehavior" />.
		              /// </summary>
		              /// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
		              /// <remarks>
		              ///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
		              /// </remarks>
		              [MockGenerator]
		              public static T Create<T>(params Action<IMockSetup<T>>[] setups)
		              	where T : class
		              {
		              	ThrowIfNotMockable(typeof(T));

		              	return new MockGenerator().Get<T>(null, MockBehavior.Default, setups)
		              		?? throw new MockException("Could not generate Mock<T>. Did the source generator run correctly?");
		              }
		              """);
		sb.AppendLine();
		sb.AppendLine("""
		              /// <summary>
		              ///     Create a new mock for <typeparamref name="T" /> with the default <see cref="MockBehavior" />.
		              /// </summary>
		              /// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
		              /// <remarks>
		              ///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
		              /// </remarks>
		              [MockGenerator]
		              public static T Create<T>(BaseClass.ConstructorParameters constructorParameters, params Action<IMockSetup<T>>[] setups)
		              	where T : class
		              {
		              	ThrowIfNotMockable(typeof(T));

		              	return new MockGenerator().Get<T>(constructorParameters, MockBehavior.Default, setups)
		              		?? throw new MockException("Could not generate Mock<T>. Did the source generator run correctly?");
		              }
		              """);
		sb.AppendLine();
		sb.AppendLine("""
		              	/// <summary>
		              	///     Create a new mock for <typeparamref name="T" /> with the given <paramref name="mockBehavior" />.
		              	/// </summary>
		              	/// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
		              	/// <remarks>
		              	///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
		              	///     <para />
		              	///     The behavior of the mock regarding the setups and the actual calls is determined by the <see cref="MockBehavior" />.
		              	/// </remarks>
		              	[MockGenerator]
		              	public static T Create<T>(MockBehavior mockBehavior, params Action<IMockSetup<T>>[] setups)
		              		where T : class
		              	{
		              		ThrowIfNotMockable(typeof(T));
		              	
		              		return new MockGenerator().Get<T>(null, mockBehavior, setups)
		              			?? throw new MockException("Could not generate Mock<T>. Did the source generator run correctly?");
		              	}
		              """);
		sb.AppendLine();
		sb.AppendLine("""
		              	/// <summary>
		              	///     Create a new mock for <typeparamref name="T" /> with the given <paramref name="mockBehavior" />.
		              	/// </summary>
		              	/// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
		              	/// <remarks>
		              	///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
		              	///     <para />
		              	///     The behavior of the mock regarding the setups and the actual calls is determined by the <see cref="MockBehavior" />.
		              	/// </remarks>
		              	[MockGenerator]
		              	public static T Create<T>(BaseClass.ConstructorParameters constructorParameters, MockBehavior mockBehavior, params Action<IMockSetup<T>>[] setups)
		              		where T : class
		              	{
		              		ThrowIfNotMockable(typeof(T));
		              	
		              		return new MockGenerator().Get<T>(constructorParameters, mockBehavior, setups)
		              			?? throw new MockException("Could not generate Mock<T>. Did the source generator run correctly?");
		              	}
		              """);
		sb.AppendLine();
		for (int numberOfArguments = 1; numberOfArguments < maxNumberOfArguments; numberOfArguments++)
		{
			string types = string.Join(", ", Enumerable.Range(2, numberOfArguments).Select(n => $"T{n}"));
			sb.AppendLine("\t/// <summary>");
			sb.Append("\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements ")
				.Append(numberOfArguments > 1 ? "interfaces " : "interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(numberOfArguments > 1 ? " and " : "")
				.Append("<typeparamref name=\"T").Append(numberOfArguments + 1).Append("\" />")
				.Append(" with the default <see cref=\"MockBehavior\" />.").AppendLine();
			sb.AppendLine("\t/// </summary>");
			sb.AppendLine(
				"\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
			for (int i = 2; i <= numberOfArguments + 1; i++)
			{
				sb.Append("\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.AppendLine($$"""
			                	/// <remarks>
			                	///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
			                	/// </remarks>
			                	[MockGenerator]
			                	public static T Create<T, {{types}}>(params Action<IMockSetup<T>>[] setups)
			                		where T : class
			                	{
			                		ThrowIfNotMockable(typeof(T));

			                		return new MockGenerator().Get<T, {{types}}>(null, MockBehavior.Default, setups)
			                			?? throw new MockException("Could not generate Mock<T, {{types}}>. Did the source generator run correctly?");
			                	}
			                """);
			sb.AppendLine();

			sb.AppendLine("\t/// <summary>");
			sb.Append("\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements ")
				.Append(numberOfArguments > 1 ? "interfaces " : "interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(numberOfArguments > 1 ? " and " : "")
				.Append("<typeparamref name=\"T").Append(numberOfArguments + 1).Append("\" />")
				.Append(" with the default <see cref=\"MockBehavior\" />.").AppendLine();
			sb.AppendLine("\t/// </summary>");
			sb.AppendLine(
				"\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
			for (int i = 2; i <= numberOfArguments + 1; i++)
			{
				sb.Append("\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.AppendLine($$"""
			                	/// <remarks>
			                	///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
			                	/// </remarks>
			                	[MockGenerator]
			                	public static T Create<T, {{types}}>(BaseClass.ConstructorParameters constructorParameters, params Action<IMockSetup<T>>[] setups)
			                		where T : class
			                	{
			                		ThrowIfNotMockable(typeof(T));

			                		return new MockGenerator().Get<T, {{types}}>(constructorParameters, MockBehavior.Default, setups)
			                			?? throw new MockException("Could not generate Mock<T, {{types}}>. Did the source generator run correctly?");
			                	}
			                """);
			sb.AppendLine();

			sb.Append("\t/// <summary>").AppendLine();
			sb.Append("\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements ")
				.Append(numberOfArguments > 1 ? "interfaces " : "interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(numberOfArguments > 1 ? " and " : "")
				.Append("<typeparamref name=\"T").Append(numberOfArguments + 1).Append("\" />")
				.Append(" with the given <paramref name=\"mockBehavior\" />.").AppendLine();
			sb.Append("\t/// </summary>").AppendLine();
			sb.Append("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>")
				.AppendLine();
			for (int i = 2; i <= numberOfArguments + 1; i++)
			{
				sb.Append("\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.AppendLine($$"""
			                	/// <remarks>
			                	///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
			                	/// </remarks>
			                	[MockGenerator]
			                	public static T Create<T, {{types}}>(MockBehavior mockBehavior, params Action<IMockSetup<T>>[] setups)
			                		where T : class
			                	{
			                		ThrowIfNotMockable(typeof(T));

			                		return new MockGenerator().Get<T, {{types}}>(null, mockBehavior, setups)
			                			?? throw new MockException("Could not generate Mock<T, {{types}}>. Did the source generator run correctly?");
			                	}
			                """);
			sb.AppendLine();

			sb.Append("\t/// <summary>").AppendLine();
			sb.Append("\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements ")
				.Append(numberOfArguments > 1 ? "interfaces " : "interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(numberOfArguments > 1 ? " and " : "")
				.Append("<typeparamref name=\"T").Append(numberOfArguments + 1).Append("\" />")
				.Append(" with the given <paramref name=\"mockBehavior\" />.").AppendLine();
			sb.Append("\t/// </summary>").AppendLine();
			sb.Append("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>")
				.AppendLine();
			for (int i = 2; i <= numberOfArguments + 1; i++)
			{
				sb.Append("\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.AppendLine($$"""
			                	/// <remarks>
			                	///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
			                	/// </remarks>
			                	[MockGenerator]
			                	public static T Create<T, {{types}}>(BaseClass.ConstructorParameters constructorParameters, MockBehavior mockBehavior, params Action<IMockSetup<T>>[] setups)
			                		where T : class
			                	{
			                		ThrowIfNotMockable(typeof(T));

			                		return new MockGenerator().Get<T, {{types}}>(constructorParameters, mockBehavior, setups)
			                			?? throw new MockException("Could not generate Mock<T, {{types}}>. Did the source generator run correctly?");
			                	}
			                """);
			sb.AppendLine();
		}

		sb.AppendLine("""
		              	/// <summary>
		              	///     A mock factory to create mocks with a common behavior.
		              	/// </summary>
		              	public partial class Factory
		              	{
		              		private MockBehavior _behavior;
		              		
		              		/// <inheritdoc cref="Factory" />
		              		public Factory(MockBehavior behavior)
		              		{
		              			_behavior = behavior;
		              		}
		              """);
		sb.AppendLine();
		sb.AppendLine("""
		              		/// <summary>
		              		///     Create a new mock for <typeparamref name="T" />.
		              		/// </summary>
		              		/// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
		              		/// <remarks>
		              		///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
		              		/// </remarks>
		              		[MockGenerator]
		              		public T Create<T>(params Action<IMockSetup<T>>[] setups)
		              			where T : class
		              		{
		              			ThrowIfNotMockable(typeof(T));
		              		
		              			return new MockGenerator().Get<T>(null, _behavior, setups)
		              				?? throw new MockException("Could not generate Mock<T>. Did the source generator run correctly?");
		              		}
		              """);
		sb.AppendLine();
		sb.AppendLine("""
		              		/// <summary>
		              		///     Create a new mock for <typeparamref name="T" />.
		              		/// </summary>
		              		/// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
		              		/// <remarks>
		              		///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
		              		/// </remarks>
		              		[MockGenerator]
		              		public T Create<T>(BaseClass.ConstructorParameters constructorParameters, params Action<IMockSetup<T>>[] setups)
		              			where T : class
		              		{
		              			ThrowIfNotMockable(typeof(T));
		              		
		              			return new MockGenerator().Get<T>(constructorParameters, _behavior, setups)
		              				?? throw new MockException("Could not generate Mock<T>. Did the source generator run correctly?");
		              		}
		              """);
		for (int numberOfArguments = 1; numberOfArguments < maxNumberOfArguments; numberOfArguments++)
		{
			string types = string.Join(", ", Enumerable.Range(2, numberOfArguments).Select(n => $"T{n}"));
			sb.AppendLine();
			sb.AppendLine("\t\t/// <summary>");
			sb.Append("\t\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements ")
				.Append(numberOfArguments > 1 ? "interfaces " : "interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(numberOfArguments > 1 ? " and " : "")
				.Append("<typeparamref name=\"T").Append(numberOfArguments + 1).Append("\" />.").AppendLine();
			sb.AppendLine("\t\t/// </summary>");
			sb.AppendLine(
				"\t\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
			for (int i = 2; i <= numberOfArguments + 1; i++)
			{
				sb.Append("\t\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.AppendLine($$"""
			                		/// <remarks>
			                		///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
			                		/// </remarks>
			                		[MockGenerator]
			                		public T Create<T, {{types}}>(params Action<IMockSetup<T>>[] setups)
			                			where T : class
			                		{
			                			ThrowIfNotMockable(typeof(T));

			                			return new MockGenerator().Get<T, {{types}}>(null, _behavior, setups)
			                				?? throw new MockException("Could not generate Mock<T, {{types}}>. Did the source generator run correctly?");
			                		}
			                """);

			sb.AppendLine();
			sb.AppendLine("\t\t/// <summary>");
			sb.Append("\t\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements ")
				.Append(numberOfArguments > 1 ? "interfaces " : "interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(numberOfArguments > 1 ? " and " : "")
				.Append("<typeparamref name=\"T").Append(numberOfArguments + 1).Append("\" />.").AppendLine();
			sb.AppendLine("\t\t/// </summary>");
			sb.AppendLine(
				"\t\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
			for (int i = 2; i <= numberOfArguments + 1; i++)
			{
				sb.Append("\t\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.AppendLine($$"""
			                		/// <remarks>
			                		///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
			                		/// </remarks>
			                		[MockGenerator]
			                		public T Create<T, {{types}}>(BaseClass.ConstructorParameters constructorParameters, params Action<IMockSetup<T>>[] setups)
			                			where T : class
			                		{
			                			ThrowIfNotMockable(typeof(T));

			                			return new MockGenerator().Get<T, {{types}}>(constructorParameters, _behavior, setups)
			                				?? throw new MockException("Could not generate Mock<T, {{types}}>. Did the source generator run correctly?");
			                		}
			                """);
		}

		sb.AppendLine("\t}");
		sb.AppendLine();

		sb.AppendLine("""
		              	/// <summary>
		              	///     Wraps a concrete instance with a mock proxy that intercepts and delegates method calls,
		              	///     supporting setup and verification on the wrapped instance.
		              	/// </summary>
		              	/// <typeparam name="T">Type to wrap, which can be an interface or a class.</typeparam>
		              	/// <param name="instance">The concrete instance to wrap.</param>
		              	/// <param name="setups">Optional setup actions to configure the mock.</param>
		              	/// <remarks>
		              	///     When no setup is specified for a method, the call is delegated to the wrapped instance.
		              	///     Setup and verification work the same as with regular mocks.
		              	/// </remarks>
		              	[MockGenerator]
		              	public static T Wrap<T>(T instance, params Action<IMockSetup<T>>[] setups)
		              		where T : class
		              	{
		              		if (instance == null)
		              		{
		              			throw new ArgumentNullException(nameof(instance));
		              		}
		              	
		              		ThrowIfNotMockable(typeof(T));
		              	
		              		return new MockGenerator().GetWrapped<T>(instance, MockBehavior.Default, setups)
		              			?? throw new MockException("Could not generate wrapped Mock<T>. Did the source generator run correctly?");
		              	}
		              """);
		sb.AppendLine();

		sb.AppendLine("""
		              	/// <summary>
		              	///     Wraps a concrete instance with a mock proxy that intercepts and delegates method calls,
		              	///     supporting setup and verification on the wrapped instance.
		              	/// </summary>
		              	/// <typeparam name="T">Type to wrap, which can be an interface or a class.</typeparam>
		              	/// <param name="instance">The concrete instance to wrap.</param>
		              	/// <param name="mockBehavior">The behavior settings for the mock.</param>
		              	/// <param name="setups">Optional setup actions to configure the mock.</param>
		              	/// <remarks>
		              	///     When no setup is specified for a method, the call is delegated to the wrapped instance.
		              	///     Setup and verification work the same as with regular mocks.
		              	/// </remarks>
		              	[MockGenerator]
		              	public static T Wrap<T>(T instance, MockBehavior mockBehavior, params Action<IMockSetup<T>>[] setups)
		              		where T : class
		              	{
		              		if (instance == null)
		              		{
		              			throw new ArgumentNullException(nameof(instance));
		              		}
		              	
		              		ThrowIfNotMockable(typeof(T));
		              	
		              		return new MockGenerator().GetWrapped<T>(instance, mockBehavior, setups)
		              			?? throw new MockException("Could not generate wrapped Mock<T>. Did the source generator run correctly?");
		              	}
		              """);
		sb.AppendLine();

		sb.AppendLine("""
		              	private static void ThrowIfNotMockable(Type type)
		              	{
		              		if (type.IsSealed && type.BaseType != typeof(MulticastDelegate))
		              		{
		              			throw new MockException($"The type '{type}' is sealed and therefore not mockable.");
		              		}
		              	}
		              """);
		sb.AppendLine();

		sb.AppendLine("""
		              	private partial class MockGenerator
		              	{
		              		#pragma warning disable CS0649 // Field 'field' is never assigned to, and will always have its default value 'value' 
		              		private object? _value;
		              		#pragma warning restore CS0649

		              		partial void Generate<T>(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior, Action<IMockSetup<T>>[] setups, params Type[] types);

		              		public object? Get(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior, Type type)
		              		{
		              			Generate<object>(constructorParameters, mockBehavior, Array.Empty<Action<IMockSetup<object>>>(), type);
		              			return _value;
		              		}

		              		public T? Get<T>(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior, Action<IMockSetup<T>>[] setups)
		              			where T : class
		              		{
		              			Generate<T>(constructorParameters, mockBehavior, setups, typeof(T));
		              			return _value as T;
		              		}
		              """);
		for (int i = 1; i < maxNumberOfArguments; i++)
		{
			string types = string.Join(", ", Enumerable.Range(2, i).Select(n => $"T{n}"));
			string typeOfTypes = string.Join(", ", Enumerable.Range(2, i).Select(n => $"typeof(T{n})"));
			sb.AppendLine($$"""
			                		public T? Get<T, {{types}}>(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior, Action<IMockSetup<T>>[] setups)
			                			where T : class
			                		{
			                			Generate<T>(constructorParameters, mockBehavior, setups, typeof(T), {{typeOfTypes}});
			                			return _value as T;
			                		}
			                """);
		}

		sb.AppendLine();
		sb.AppendLine("""
		              		partial void GenerateWrapped<T>(T instance, MockBehavior mockBehavior, Action<IMockSetup<T>>[] setups);
		              		
		              		public T? GetWrapped<T>(T instance, MockBehavior mockBehavior, Action<IMockSetup<T>>[] setups)
		              			where T : class
		              		{
		              			GenerateWrapped<T>(instance, mockBehavior, setups);
		              			return _value as T;
		              		}
		              """);

		sb.AppendLine("""
		              	}
		              }
		              #nullable disable
		              """);
		return sb.ToString();
	}

	/// <summary>
	///     Creates the <c>MockGenerator</c> attribute.
	/// </summary>
	public static string MockGeneratorAttribute()
	{
		StringBuilder sb = InitializeBuilder([
			"System",
		]);

		sb.AppendLine("""
		              namespace Mockolate;

		              /// <summary>
		              ///     Marks a method as a mock generator for its generic parameters.
		              /// </summary>
		              [AttributeUsage(AttributeTargets.Method)]
		              public class MockGeneratorAttribute : Attribute
		              {
		              }
		              """);
		return sb.ToString();
	}

	internal static string ToVisibilityString(this Accessibility accessibility)
		=> accessibility switch
		{
			Accessibility.Private => "private",
			Accessibility.Protected => "protected",
			Accessibility.Internal => "internal",
			Accessibility.ProtectedOrInternal => "protected",
			Accessibility.Public => "public",
			Accessibility.ProtectedAndInternal => "private protected",
			_ => throw new ArgumentOutOfRangeException(nameof(accessibility), accessibility, null),
		};

	internal static string GetString(this RefKind refKind)
		=> refKind switch
		{
			RefKind.None => "",
			RefKind.In => "in ",
			RefKind.Out => "out ",
			RefKind.Ref => "ref ",
			RefKind.RefReadOnlyParameter => "ref readonly ",
			_ => "",
		};

	internal static string EscapeForXmlDoc(this string value)
		=> value.Replace('<', '{').Replace('>', '}');
}
#pragma warning restore S3776 // Cognitive Complexity of methods should not be too high
