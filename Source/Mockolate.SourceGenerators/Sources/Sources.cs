using System.Text;
using Microsoft.CodeAnalysis;

namespace Mockolate.SourceGenerators.Internals;

#pragma warning disable S3776 // Cognitive Complexity of methods should not be too high
internal static partial class Sources
{
	private static StringBuilder InitializeBuilder(string[] namespaces)
	{
		StringBuilder sb = new();
		sb.AppendLine("""
			//----------------------
			// <auto-generated>
			//     This code was generated by the Mockolate source generator.
			//
			//     Changes to this file may cause incorrect behavior and
			//     will be lost if the code is regenerated!
			// </auto-generated>
			//----------------------
			""");
		sb.AppendLine();
		foreach (string @namespace in namespaces)
		{
			sb.Append("using ").Append(@namespace).AppendLine(";");
		}
		sb.AppendLine();
		return sb;
	}

	/// <summary>
	///     Creates the static <c>Mock</c> class with the <c>Create</c> methods to create new mocks.
	/// </summary>
	public static string MockClass()
	{
		StringBuilder sb = InitializeBuilder([
			"System",
			"Mockolate.Exceptions",
		]);

		int maxNumberOfArguments = 9;
		sb.AppendLine("""
			namespace Mockolate;

			#nullable enable
			/// <summary>
			///     Create new mocks by calling <c>Mock.Create&lt;T&gt;()</c>.<br />
			///     You can specify up to eight additional interfaces that the mock will also implement.
			/// </summary>
			/// <remarks>
			///     If your type is a class without default constructor, you can provide constructor parameters using <see cref="BaseClass.WithConstructorParameters(object?[])" />.
			///     You can also provide a <see cref="MockBehavior"/> parameter to customize how the mock should behave in certain scenarios.
			/// </remarks>
			internal static partial class Mock
			{
			""");
		sb.AppendLine("""
				/// <summary>
				///     Create a new mock for <typeparamref name="T" /> with the default <see cref="MockBehavior" />.
				/// </summary>
				/// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
				/// <remarks>
				///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
				/// </remarks>
				[MockGenerator]
				public static Mock<T> Create<T>(BaseClass.ConstructorParameters? constructorParameters = null)
				{
					ThrowIfNotMockable(typeof(T));

					return new MockGenerator().Get<T>(constructorParameters, MockBehavior.Default)
						?? throw new MockException("Could not generate Mock<T>. Did the source generator run correctly?");
				}
			""");
		sb.AppendLine();
		sb.AppendLine("""
				/// <summary>
				///     Create a new mock for <typeparamref name="T" /> with the given <paramref name="mockBehavior" />.
				/// </summary>
				/// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
				/// <remarks>
				///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
				///     <para />
				///     The behavior of the mock with regards to the setups and the actual calls is determined by the <see cref="MockBehavior" />.
				/// </remarks>
				[MockGenerator]
				public static Mock<T> Create<T>(MockBehavior mockBehavior)
				{
					ThrowIfNotMockable(typeof(T));
				
					return new MockGenerator().Get<T>(null, mockBehavior)
						?? throw new MockException("Could not generate Mock<T>. Did the source generator run correctly?");
				}
			""");
		sb.AppendLine();
		sb.AppendLine("""
				/// <summary>
				///     Create a new mock for <typeparamref name="T" /> with the given <paramref name="mockBehavior" />.
				/// </summary>
				/// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
				/// <remarks>
				///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
				///     <para />
				///     The behavior of the mock with regards to the setups and the actual calls is determined by the <see cref="MockBehavior" />.
				/// </remarks>
				[MockGenerator]
				public static Mock<T> Create<T>(BaseClass.ConstructorParameters constructorParameters, MockBehavior mockBehavior)
				{
					ThrowIfNotMockable(typeof(T));
				
					return new MockGenerator().Get<T>(constructorParameters, mockBehavior)
						?? throw new MockException("Could not generate Mock<T>. Did the source generator run correctly?");
				}
			""");
		sb.AppendLine();
		for (int numberOfArguments = 1; numberOfArguments < maxNumberOfArguments; numberOfArguments++)
		{
			string types = string.Join(", ", Enumerable.Range(2, numberOfArguments).Select(n => $"T{n}"));
			sb.AppendLine("\t/// <summary>");
			sb.Append("\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements ")
				.Append(numberOfArguments > 1 ? "interfaces " : "interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(numberOfArguments > 1 ? " and " : "")
				.Append("<typeparamref name=\"T").Append(numberOfArguments + 1).Append("\" />")
				.Append(" with the default <see cref=\"MockBehavior\" />.").AppendLine();
			sb.AppendLine("\t/// </summary>");
			sb.AppendLine(
				"\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
			for (int i = 2; i <= numberOfArguments + 1; i++)
			{
				sb.Append("\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}
			sb.AppendLine($$"""
				/// <remarks>
				///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
				/// </remarks>
				[MockGenerator]
				public static Mock<T, {{types}}> Create<T, {{types}}>(BaseClass.ConstructorParameters? constructorParameters = null)
				{
					ThrowIfNotMockable(typeof(T));
	
					return new MockGenerator().Get<T, {{types}}>(constructorParameters, MockBehavior.Default)
						?? throw new MockException("Could not generate Mock<T, {{types}}>. Did the source generator run correctly?");
				}
			""");
			sb.AppendLine();

			sb.Append("\t/// <summary>").AppendLine();
			sb.Append("\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements ")
				.Append(numberOfArguments > 1 ? "interfaces " : "interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(numberOfArguments > 1 ? " and " : "")
				.Append("<typeparamref name=\"T").Append(numberOfArguments + 1).Append("\" />")
				.Append(" with the given <paramref name=\"mockBehavior\" />.").AppendLine();
			sb.Append("\t/// </summary>").AppendLine();
			sb.Append("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>")
				.AppendLine();
			for (int i = 2; i <= numberOfArguments + 1; i++)
			{
				sb.Append("\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.AppendLine($$"""
				/// <remarks>
				///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
				/// </remarks>
				[MockGenerator]
				public static Mock<T, {{types}}> Create<T, {{types}}>(MockBehavior mockBehavior)
				{
					ThrowIfNotMockable(typeof(T));
			
					return new MockGenerator().Get<T, {{types}}>(null, mockBehavior)
						?? throw new MockException("Could not generate Mock<T, {{types}}>. Did the source generator run correctly?");
				}
			""");
			sb.AppendLine();

			sb.Append("\t/// <summary>").AppendLine();
			sb.Append("\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements ")
				.Append(numberOfArguments > 1 ? "interfaces " : "interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(numberOfArguments > 1 ? " and " : "")
				.Append("<typeparamref name=\"T").Append(numberOfArguments + 1).Append("\" />")
				.Append(" with the given <paramref name=\"mockBehavior\" />.").AppendLine();
			sb.Append("\t/// </summary>").AppendLine();
			sb.Append("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>")
				.AppendLine();
			for (int i = 2; i <= numberOfArguments + 1; i++)
			{
				sb.Append("\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}
			sb.AppendLine($$"""
				/// <remarks>
				///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
				/// </remarks>
				[MockGenerator]
				public static Mock<T, {{types}}> Create<T, {{types}}>(BaseClass.ConstructorParameters constructorParameters, MockBehavior mockBehavior)
				{
					ThrowIfNotMockable(typeof(T));
			
					return new MockGenerator().Get<T, {{types}}>(constructorParameters, mockBehavior)
						?? throw new MockException("Could not generate Mock<T, {{types}}>. Did the source generator run correctly?");
				}
			""");
			sb.AppendLine();
		}

		sb.AppendLine("""
				/// <summary>
				///     A mock factory to create mocks with a common behavior.
				/// </summary>
				public partial class Factory
				{
					private MockBehavior _behavior;
					
					/// <inheritdoc cref="Factory" />
					public Factory(MockBehavior behavior)
					{
						_behavior = behavior;
					}
			""");
		sb.AppendLine();
		sb.AppendLine("""
					/// <summary>
					///     Create a new mock for <typeparamref name="T" />.
					/// </summary>
					/// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
					/// <remarks>
					///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
					/// </remarks>
					[MockGenerator]
					public Mock<T> Create<T>(BaseClass.ConstructorParameters? constructorParameters = null)
					{
						ThrowIfNotMockable(typeof(T));
					
						return new MockGenerator().Get<T>(constructorParameters, _behavior)
							?? throw new MockException("Could not generate Mock<T>. Did the source generator run correctly?");
					}
			""");
		for (int numberOfArguments = 1; numberOfArguments < maxNumberOfArguments; numberOfArguments++)
		{
			string types = string.Join(", ", Enumerable.Range(2, numberOfArguments).Select(n => $"T{n}"));
			sb.AppendLine();
			sb.AppendLine("\t\t/// <summary>");
			sb.Append("\t\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements ")
				.Append(numberOfArguments > 1 ? "interfaces " : "interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(numberOfArguments > 1 ? " and " : "")
				.Append("<typeparamref name=\"T").Append(numberOfArguments + 1).Append("\" />.").AppendLine();
			sb.AppendLine("\t\t/// </summary>");
			sb.AppendLine(
				"\t\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
			for (int i = 2; i <= numberOfArguments + 1; i++)
			{
				sb.Append("\t\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.AppendLine($$"""
					/// <remarks>
					///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
					/// </remarks>
					[MockGenerator]
					public Mock<T, {{types}}> Create<T, {{types}}>(BaseClass.ConstructorParameters? constructorParameters = null)
					{
						ThrowIfNotMockable(typeof(T));
			
						return new MockGenerator().Get<T, {{types}}>(constructorParameters, _behavior)
							?? throw new MockException("Could not generate Mock<T, {{types}}>. Did the source generator run correctly?");
					}
			""");
		}
		sb.AppendLine("\t}");
		sb.AppendLine();

		sb.AppendLine("""
				private static void ThrowIfNotMockable(Type type)
				{
					if (type.IsSealed && type.BaseType != typeof(MulticastDelegate))
					{
						throw new MockException($"The type '{type}' is sealed and therefore not mockable.");
					}
				}
			""");
		sb.AppendLine();

		sb.AppendLine("""
				private partial class MockGenerator
				{
					#pragma warning disable CS0649 // Field 'field' is never assigned to, and will always have its default value 'value' 
					private object? _value;
					#pragma warning restore CS0649

					partial void Generate(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior, params Type[] types);

					public Mock<T>? Get<T>(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior)
					{
						Generate(constructorParameters, mockBehavior, typeof(T));
						return _value as Mock<T>;
					}
			""");
		for (int i = 1; i < maxNumberOfArguments; i++)
		{
			string types = string.Join(", ", Enumerable.Range(2, i).Select(n => $"T{n}"));
			string typeOfTypes = string.Join(", ", Enumerable.Range(2, i).Select(n => $"typeof(T{n})"));
			sb.AppendLine($$"""
					public Mock<T, {{types}}>? Get<T, {{types}}>(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior)
					{
						Generate(constructorParameters, mockBehavior, typeof(T), {{typeOfTypes}});
						return _value as Mock<T, {{types}}>;
					}
			""");
		}

		sb.AppendLine("""
				}
			}
			#nullable disable
			""");
		return sb.ToString();
	}

	/// <summary>
	///     Creates the <c>MockGenerator</c> attribute.
	/// </summary>
	public static string MockGeneratorAttribute()
	{
		StringBuilder sb = InitializeBuilder([
			"System",
		]);

		sb.AppendLine("""
			namespace Mockolate;

			/// <summary>
			///     Marks a method as a mock generator for its generic parameters.
			/// </summary>
			[AttributeUsage(AttributeTargets.Method)]
			public class MockGeneratorAttribute : Attribute
			{
			}
			""");
		return sb.ToString();
	}

	internal static string ToVisibilityString(this Accessibility accessibility)
		=> accessibility switch
		{
			Accessibility.Private => "private",
			Accessibility.Protected => "protected",
			Accessibility.Internal => "internal",
			Accessibility.ProtectedOrInternal => "protected",
			Accessibility.Public => "public",
			Accessibility.ProtectedAndInternal => "private protected",
			_ => throw new ArgumentOutOfRangeException(nameof(accessibility), accessibility, null),
		};

	internal static string GetString(this RefKind refKind)
		=> refKind switch
		{
			RefKind.None => "",
			RefKind.In => "in ",
			RefKind.Out => "out ",
			RefKind.Ref => "ref ",
			RefKind.RefReadOnlyParameter => "ref readonly ",
			_ => "",
		};

	internal static string EscapeForXmlDoc(this string value)
		=> value.Replace('<', '{').Replace('>', '}');
}
#pragma warning restore S3776 // Cognitive Complexity of methods should not be too high
