using System.Text;
using Microsoft.CodeAnalysis;

namespace Mockolate.SourceGenerators.Internals;

#pragma warning disable S3776 // Cognitive Complexity of methods should not be too high
internal static partial class Sources
{
	private static StringBuilder InitializeBuilder(string[] namespaces)
	{
		StringBuilder sb = new();
		sb.AppendLine("""
			//----------------------
			// <auto-generated>
			//     This code was generated by the Mockolate source generator.
			//
			//     Changes to this file may cause incorrect behavior and
			//     will be lost if the code is regenerated!
			// </auto-generated>
			//----------------------
			""");
		sb.AppendLine();
		foreach (string @namespace in namespaces)
		{
			sb.Append("using ").Append(@namespace).AppendLine(";");
		}
		sb.AppendLine();
		return sb;
	}

	/// <summary>
	///     Creates the static <c>Mock</c> class with the <c>Create</c> methods to create new mocks.
	/// </summary>
	public static string MockClass()
	{
		StringBuilder sb = InitializeBuilder([
			"System",
			"Mockolate.Exceptions",
		]);

		int maxNumberOfArguments = 9;
		sb.AppendLine("namespace Mockolate;");
		sb.AppendLine();
		sb.AppendLine("#nullable enable");
		sb.AppendLine("/// <summary>");
		sb.AppendLine("///     Create new mocks by calling <c>Mock.Create&lt;T&gt;()</c>.<br />");
		sb.AppendLine("///     You can specify up to eight additional interfaces that the mock will also implement.");
		sb.AppendLine("/// </summary>");
		sb.AppendLine("/// <remarks>");
		sb.AppendLine("///     If your type is a class without default constructor, you can provide constructor parameters using <see cref=\"BaseClass.WithConstructorParameters(object?[])\" />.");
		sb.AppendLine("///     You can also provide a <see cref=\"MockBehavior\"/> parameter to customize how the mock should behave in certain scenarios.");
		sb.AppendLine("/// </remarks>");
		sb.AppendLine("internal static partial class Mock");
		sb.AppendLine("{");
		sb.AppendLine("\t/// <summary>");
		sb.AppendLine(
			"\t///     Create a new mock for <typeparamref name=\"T\" /> with the default <see cref=\"MockBehavior\" />.");
		sb.AppendLine("\t/// </summary>");
		sb.AppendLine("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
		sb.AppendLine("\t/// <remarks>");
		sb.AppendLine(
			"\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.");
		sb.AppendLine("\t/// </remarks>");
		sb.AppendLine("\tpublic static Mock<T> Create<T>(BaseClass.ConstructorParameters? constructorParameters = null)");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\tThrowIfNotMockable(typeof(T));");
		sb.AppendLine();
		sb.AppendLine("\t\treturn new MockGenerator().Get<T>(constructorParameters, MockBehavior.Default)");
		sb.AppendLine(
			"\t\t\t?? throw new MockException(\"Could not generate Mock<T>. Did the source generator run correctly?\");");
		sb.AppendLine("\t}");
		sb.AppendLine();
		sb.AppendLine("\t/// <summary>");
		sb.AppendLine(
			"\t///     Create a new mock for <typeparamref name=\"T\" /> with the given <paramref name=\"mockBehavior\" />.");
		sb.AppendLine("\t/// </summary>");
		sb.AppendLine("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
		sb.AppendLine("\t/// <remarks>");
		sb.AppendLine(
			"\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.");
		sb.AppendLine("\t///     <para />");
		sb.AppendLine(
			"\t///     The behavior of the mock with regards to the setups and the actual calls is determined by the <see cref=\"MockBehavior\" />.");
		sb.AppendLine("\t/// </remarks>");
		sb.AppendLine("\tpublic static Mock<T> Create<T>(MockBehavior mockBehavior)");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\tThrowIfNotMockable(typeof(T));");
		sb.AppendLine();
		sb.AppendLine("\t\treturn new MockGenerator().Get<T>(null, mockBehavior)");
		sb.AppendLine(
			"\t\t\t?? throw new MockException(\"Could not generate Mock<T>. Did the source generator run correctly?\");");
		sb.AppendLine("\t}");
		sb.AppendLine();
		sb.AppendLine("\t/// <summary>");
		sb.AppendLine(
			"\t///     Create a new mock for <typeparamref name=\"T\" /> with the given <paramref name=\"mockBehavior\" />.");
		sb.AppendLine("\t/// </summary>");
		sb.AppendLine("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
		sb.AppendLine("\t/// <remarks>");
		sb.AppendLine(
			"\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.");
		sb.AppendLine("\t///     <para />");
		sb.AppendLine(
			"\t///     The behavior of the mock with regards to the setups and the actual calls is determined by the <see cref=\"MockBehavior\" />.");
		sb.AppendLine("\t/// </remarks>");
		sb.AppendLine(
			"\tpublic static Mock<T> Create<T>(BaseClass.ConstructorParameters constructorParameters, MockBehavior mockBehavior)");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\tThrowIfNotMockable(typeof(T));");
		sb.AppendLine();
		sb.AppendLine("\t\treturn new MockGenerator().Get<T>(constructorParameters, mockBehavior)");
		sb.AppendLine(
			"\t\t\t?? throw new MockException(\"Could not generate Mock<T>. Did the source generator run correctly?\");");
		sb.AppendLine("\t}");
		sb.AppendLine();
		for (int numberOfArguments = 1; numberOfArguments < maxNumberOfArguments; numberOfArguments++)
		{
			sb.AppendLine();
			string types = string.Join(", ", Enumerable.Range(2, numberOfArguments).Select(n => $"T{n}"));
			sb.AppendLine("\t/// <summary>");
			sb.Append("\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements ")
				.Append(numberOfArguments > 1 ? "interfaces " : "interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(numberOfArguments > 1 ? " and " : "")
				.Append("<typeparamref name=\"T").Append(numberOfArguments + 1).Append("\" />")
				.Append(" with the default <see cref=\"MockBehavior\" />.").AppendLine();
			sb.AppendLine("\t/// </summary>");
			sb.AppendLine(
				"\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
			for (int i = 2; i <= numberOfArguments + 1; i++)
			{
				sb.Append("\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.Append("\t/// <remarks>").AppendLine();
			sb.Append(
					"\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.")
				.AppendLine();
			sb.Append("\t/// </remarks>").AppendLine();
			sb.Append("\tpublic static Mock<T, ").Append(types).Append("> Create<T, ").Append(types)
				.Append(">(BaseClass.ConstructorParameters? constructorParameters = null)").AppendLine();
			sb.Append("\t{").AppendLine();
			sb.Append("\t\treturn new MockGenerator().Get<T, ").Append(types)
				.Append(">(constructorParameters, MockBehavior.Default)").AppendLine();
			sb.Append("\t\t\t?? throw new MockException(\"Could not generate Mock<T, ").Append(types)
				.Append(">. Did the source generator run correctly?\");").AppendLine();
			sb.Append("\t}").AppendLine();
			sb.AppendLine();
			sb.Append("\t/// <summary>").AppendLine();
			sb.Append("\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements ")
				.Append(numberOfArguments > 1 ? "interfaces " : "interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(numberOfArguments > 1 ? " and " : "")
				.Append("<typeparamref name=\"T").Append(numberOfArguments + 1).Append("\" />")
				.Append(" with the given <paramref name=\"mockBehavior\" />.").AppendLine();
			sb.Append("\t/// </summary>").AppendLine();
			sb.Append("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>")
				.AppendLine();
			for (int i = 2; i <= numberOfArguments + 1; i++)
			{
				sb.Append("\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.Append("\t/// <remarks>").AppendLine();
			sb.Append(
					"\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.")
				.AppendLine();
			sb.Append("\t/// </remarks>").AppendLine();
			sb.Append("\tpublic static Mock<T, ").Append(types).Append("> Create<T, ").Append(types)
				.Append(">(MockBehavior mockBehavior)").AppendLine();
			sb.Append("\t{").AppendLine();
			sb.Append("\t\treturn new MockGenerator().Get<T, ").Append(types).Append(">(null, mockBehavior)")
				.AppendLine();
			sb.Append("\t\t\t?? throw new MockException(\"Could not generate Mock<T, ").Append(types)
				.Append(">. Did the source generator run correctly?\");").AppendLine();
			sb.Append("\t}").AppendLine();
			sb.AppendLine();
			sb.Append("\t/// <summary>").AppendLine();
			sb.Append("\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements ")
				.Append(numberOfArguments > 1 ? "interfaces " : "interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(numberOfArguments > 1 ? " and " : "")
				.Append("<typeparamref name=\"T").Append(numberOfArguments + 1).Append("\" />")
				.Append(" with the given <paramref name=\"mockBehavior\" />.").AppendLine();
			sb.Append("\t/// </summary>").AppendLine();
			sb.Append("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>")
				.AppendLine();
			for (int i = 2; i <= numberOfArguments + 1; i++)
			{
				sb.Append("\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.Append("\t/// <remarks>").AppendLine();
			sb.Append(
					"\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.")
				.AppendLine();
			sb.Append("\t/// </remarks>").AppendLine();
			sb.Append("\tpublic static Mock<T, ").Append(types).Append("> Create<T, ").Append(types)
				.Append(">(BaseClass.ConstructorParameters constructorParameters, MockBehavior mockBehavior)")
				.AppendLine();
			sb.Append("\t{").AppendLine();
			sb.Append("\t\treturn new MockGenerator().Get<T, ").Append(types)
				.Append(">(constructorParameters, mockBehavior)").AppendLine();
			sb.Append("\t\t\t?? throw new MockException(\"Could not generate Mock<T, ").Append(types)
				.Append(">. Did the source generator run correctly?\");").AppendLine();
			sb.Append("\t}").AppendLine();
			sb.AppendLine();
		}

		sb.AppendLine("\t/// <summary>");
		sb.AppendLine("\t///     A mock factory to create mocks with a common behavior.");
		sb.AppendLine("\t/// </summary>");
		sb.AppendLine("\tpublic partial class Factory");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\tprivate MockBehavior _behavior;");
		sb.AppendLine();
		sb.AppendLine("\t\t/// <inheritdoc cref=\"Factory\" />");
		sb.AppendLine("\t\tpublic Factory(MockBehavior behavior)");
		sb.AppendLine("\t\t{");
		sb.AppendLine("\t\t\t_behavior = behavior;");
		sb.AppendLine("\t\t}");
		sb.AppendLine();
		sb.AppendLine("\t\t/// <summary>");
		sb.AppendLine(
			"\t\t///     Create a new mock for <typeparamref name=\"T\" />.");
		sb.AppendLine("\t\t/// </summary>");
		sb.AppendLine("\t\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
		sb.AppendLine("\t\t/// <remarks>");
		sb.AppendLine(
			"\t\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.");
		sb.AppendLine("\t\t/// </remarks>");
		sb.AppendLine("\t\tpublic Mock<T> Create<T>(BaseClass.ConstructorParameters? constructorParameters = null)");
		sb.AppendLine("\t\t{");
		sb.AppendLine("\t\t\tThrowIfNotMockable(typeof(T));");
		sb.AppendLine();
		sb.Append("\t\t\treturn new MockGenerator().Get<T>(constructorParameters, _behavior)").AppendLine();
		sb.Append("\t\t\t\t?? throw new MockException(\"Could not generate Mock<T>. Did the source generator run correctly?\");").AppendLine();
		sb.AppendLine("\t\t}");
		for (int numberOfArguments = 1; numberOfArguments < maxNumberOfArguments; numberOfArguments++)
		{
			sb.AppendLine();
			string types = string.Join(", ", Enumerable.Range(2, numberOfArguments).Select(n => $"T{n}"));
			sb.AppendLine("\t\t/// <summary>");
			sb.Append("\t\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements ")
				.Append(numberOfArguments > 1 ? "interfaces " : "interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(numberOfArguments > 1 ? " and " : "")
				.Append("<typeparamref name=\"T").Append(numberOfArguments + 1).Append("\" />.").AppendLine();
			sb.AppendLine("\t\t/// </summary>");
			sb.AppendLine(
				"\t\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
			for (int i = 2; i <= numberOfArguments + 1; i++)
			{
				sb.Append("\t\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.Append("\t\t/// <remarks>").AppendLine();
			sb.Append(
					"\t\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.")
				.AppendLine();
			sb.Append("\t\t/// </remarks>").AppendLine();
			sb.Append("\t\tpublic Mock<T, ").Append(types).Append("> Create<T, ").Append(types)
				.Append(">(BaseClass.ConstructorParameters? constructorParameters = null)").AppendLine();
			sb.Append("\t\t{").AppendLine();
			sb.Append("\t\t\treturn new MockGenerator().Get<T, ").Append(types)
				.Append(">(constructorParameters, _behavior)").AppendLine();
			sb.Append("\t\t\t\t?? throw new MockException(\"Could not generate Mock<T, ").Append(types)
				.Append(">. Did the source generator run correctly?\");").AppendLine();
			sb.Append("\t\t}").AppendLine();
		}
		sb.AppendLine("\t}");
		sb.AppendLine();

		sb.AppendLine("\tprivate static void ThrowIfNotMockable(Type type)");
		sb.AppendLine("\t{");
		sb.Append("\t\tif (type.IsSealed && type.BaseType != typeof(MulticastDelegate))").AppendLine();
		sb.Append("\t\t{").AppendLine();
		sb.Append("\t\t\tthrow new MockException($\"The type '{type}' is sealed and therefore not mockable.\");").AppendLine();
		sb.Append("\t\t}").AppendLine();
		sb.AppendLine("\t}");
		sb.AppendLine();

		sb.Append("\tprivate partial class MockGenerator").AppendLine();
		sb.Append("\t{").AppendLine();
		sb.Append("\t\t#pragma warning disable CS0649 // Field 'field' is never assigned to, and will always have its default value 'value' ").AppendLine();
		sb.Append("\t\tprivate object? _value;").AppendLine();
		sb.Append("\t\t#pragma warning restore CS0649").AppendLine();
		sb.Append(
				"\t\tpartial void Generate(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior, params Type[] types);")
			.AppendLine();
		sb.Append(
				"\t\tpublic Mock<T>? Get<T>(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior)")
			.AppendLine();
		sb.Append("\t\t{").AppendLine();
		sb.Append("\t\t\tGenerate(constructorParameters, mockBehavior, typeof(T));").AppendLine();
		sb.Append("\t\t\treturn _value as Mock<T>;").AppendLine();
		sb.Append("\t\t}").AppendLine();
		for (int i = 1; i < maxNumberOfArguments; i++)
		{
			string types = string.Join(", ", Enumerable.Range(2, i).Select(n => $"T{n}"));
			sb.Append("\t\tpublic Mock<T, ").Append(types).Append(">? Get<T, ").Append(types)
				.Append(">(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior)")
				.AppendLine();
			sb.Append("\t\t{").AppendLine();
			sb.Append("\t\t\tGenerate(constructorParameters, mockBehavior, typeof(T), ")
				.Append(string.Join(", ", Enumerable.Range(2, i).Select(n => $"typeof(T{n})"))).Append(");")
				.AppendLine();
			sb.Append("\t\t\treturn _value as Mock<T, ").Append(types).Append(">;").AppendLine();
			sb.Append("\t\t}").AppendLine();
		}

		sb.Append("\t}").AppendLine();
		sb.Append("}").AppendLine();
		sb.Append("#nullable disable").AppendLine();

		return sb.ToString();
	}

	internal static string ToVisibilityString(this Accessibility accessibility)
		=> accessibility switch
		{
			Accessibility.Private => "private",
			Accessibility.Protected => "protected",
			Accessibility.Internal => "internal",
			Accessibility.ProtectedOrInternal => "protected",
			Accessibility.Public => "public",
			Accessibility.ProtectedAndInternal => "private protected",
			_ => throw new ArgumentOutOfRangeException(nameof(accessibility), accessibility, null),
		};

	internal static string GetString(this RefKind refKind)
		=> refKind switch
		{
			RefKind.None => "",
			RefKind.In => "in ",
			RefKind.Out => "out ",
			RefKind.Ref => "ref ",
			RefKind.RefReadOnlyParameter => "ref readonly ",
			_ => "",
		};

	internal static string EscapeForXmlDoc(this string value)
		=> value.Replace('<', '{').Replace('>', '}');
}
#pragma warning restore S3776 // Cognitive Complexity of methods should not be too high
