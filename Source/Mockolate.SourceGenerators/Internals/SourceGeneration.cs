using System.Text;
using Microsoft.CodeAnalysis;

namespace Mockolate.SourceGenerators.Internals;

internal static partial class SourceGeneration
{
	public const string Header =
		"""
		//----------------------
		// <auto-generated>
		//     This code was generated by the 'Mockolate' source generator.
		//
		//     Changes to this file may cause incorrect behavior and
		//     will be lost if the code is regenerated!
		// </auto-generated>
		//----------------------

		""";

	public static string Mock()
	{
		int maxNumberOfArguments = 9;
		StringBuilder sb = new();
		sb.AppendLine(Header);
		sb.AppendLine("using System;");
		sb.AppendLine("using Mockolate.Exceptions;");
		sb.AppendLine();
		sb.AppendLine("namespace Mockolate;");
		sb.AppendLine();
		sb.AppendLine("#nullable enable");
		sb.AppendLine("/// <summary>");
		sb.AppendLine("///     Create new mocks by calling <see cref=\"Mock.Create{T}\" />.");
		sb.AppendLine("/// </summary>");
		sb.AppendLine("public static partial class Mock");
		sb.AppendLine("{");
		sb.AppendLine("\t/// <summary>");
		sb.AppendLine(
			"\t///     Create a new mock for <typeparamref name=\"T\" /> with the default <see cref=\"MockBehavior\" />.");
		sb.AppendLine("\t/// </summary>");
		sb.AppendLine("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
		sb.AppendLine("\t/// <remarks>");
		sb.AppendLine(
			"\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.");
		sb.AppendLine("\t/// </remarks>");
		sb.AppendLine("\tpublic static Mock<T> Create<T>(BaseClass.ConstructorParameters? constructorParameters = null)");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\treturn new MockGenerator().Get<T>(constructorParameters, MockBehavior.Default)");
		sb.AppendLine(
			"\t\t\t?? throw new MockException(\"Could not generate Mock<T>. Did the source generator run correctly?\");");
		sb.AppendLine("\t}");
		sb.AppendLine();
		sb.AppendLine("\t/// <summary>");
		sb.AppendLine(
			"\t///     Create a new mock for <typeparamref name=\"T\" /> with the given <paramref name=\"mockBehavior\" />.");
		sb.AppendLine("\t/// </summary>");
		sb.AppendLine("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
		sb.AppendLine("\t/// <remarks>");
		sb.AppendLine(
			"\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.");
		sb.AppendLine("\t///     <para />");
		sb.AppendLine(
			"\t///     The behavior of the mock with regards to the setups and the actual calls is determined by the <see cref=\"MockBehavior\" />.");
		sb.AppendLine("\t/// </remarks>");
		sb.AppendLine("\tpublic static Mock<T> Create<T>(MockBehavior mockBehavior)");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\treturn new MockGenerator().Get<T>(null, mockBehavior)");
		sb.AppendLine(
			"\t\t\t?? throw new MockException(\"Could not generate Mock<T>. Did the source generator run correctly?\");");
		sb.AppendLine("\t}");
		sb.AppendLine();
		sb.AppendLine("\t/// <summary>");
		sb.AppendLine(
			"\t///     Create a new mock for <typeparamref name=\"T\" /> with the given <paramref name=\"mockBehavior\" />.");
		sb.AppendLine("\t/// </summary>");
		sb.AppendLine("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
		sb.AppendLine("\t/// <remarks>");
		sb.AppendLine(
			"\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.");
		sb.AppendLine("\t///     <para />");
		sb.AppendLine(
			"\t///     The behavior of the mock with regards to the setups and the actual calls is determined by the <see cref=\"MockBehavior\" />.");
		sb.AppendLine("\t/// </remarks>");
		sb.AppendLine(
			"\tpublic static Mock<T> Create<T>(BaseClass.ConstructorParameters constructorParameters, MockBehavior mockBehavior)");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\treturn new MockGenerator().Get<T>(constructorParameters, mockBehavior)");
		sb.AppendLine(
			"\t\t\t?? throw new MockException(\"Could not generate Mock<T>. Did the source generator run correctly?\");");
		sb.AppendLine("\t}");
		sb.AppendLine();
		for (int numberOfArguments = 1; numberOfArguments < maxNumberOfArguments; numberOfArguments++)
		{
			sb.AppendLine();
			string types = string.Join(", ", Enumerable.Range(2, numberOfArguments).Select(n => $"T{n}"));
			sb.AppendLine("\t/// <summary>");
			sb.Append("\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(" and <typeparamref name=\"T").Append(numberOfArguments).Append("\" />")
				.Append(" with the default <see cref=\"MockBehavior\" />.").AppendLine();
			sb.AppendLine("\t/// </summary>");
			sb.AppendLine(
				"\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
			for (int i = 2; i <= numberOfArguments; i++)
			{
				sb.Append("\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.Append("\t/// <remarks>").AppendLine();
			sb.Append(
					"\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.")
				.AppendLine();
			sb.Append("\t/// </remarks>").AppendLine();
			sb.Append("\tpublic static Mock<T, ").Append(types).Append("> Create<T, ").Append(types)
				.Append(">(BaseClass.ConstructorParameters? constructorParameters = null)").AppendLine();
			sb.Append("\t{").AppendLine();
			sb.Append("\t\treturn new MockGenerator().Get<T, ").Append(types)
				.Append(">(constructorParameters, MockBehavior.Default)").AppendLine();
			sb.Append("\t\t\t?? throw new MockException(\"Could not generate Mock<T, ").Append(types)
				.Append(">. Did the source generator run correctly?\");").AppendLine();
			sb.Append("\t}").AppendLine();
			sb.AppendLine();
			sb.Append("\t/// <summary>").AppendLine();
			sb.Append("\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(" and <typeparamref name=\"T").Append(numberOfArguments).Append("\" />")
				.Append(" with the given <paramref name=\"mockBehavior\" />.").AppendLine();
			sb.Append("\t/// </summary>").AppendLine();
			sb.Append("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>")
				.AppendLine();
			for (int i = 2; i <= numberOfArguments; i++)
			{
				sb.Append("\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.Append("\t/// <remarks>").AppendLine();
			sb.Append(
					"\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.")
				.AppendLine();
			sb.Append("\t/// </remarks>").AppendLine();
			sb.Append("\tpublic static Mock<T, ").Append(types).Append("> Create<T, ").Append(types)
				.Append(">(MockBehavior mockBehavior)").AppendLine();
			sb.Append("\t{").AppendLine();
			sb.Append("\t\treturn new MockGenerator().Get<T, ").Append(types).Append(">(null, mockBehavior)")
				.AppendLine();
			sb.Append("\t\t\t?? throw new MockException(\"Could not generate Mock<T, ").Append(types)
				.Append(">. Did the source generator run correctly?\");").AppendLine();
			sb.Append("\t}").AppendLine();
			sb.AppendLine();
			sb.Append("\t/// <summary>").AppendLine();
			sb.Append("\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(" and <typeparamref name=\"T").Append(numberOfArguments).Append("\" />")
				.Append(" with the given <paramref name=\"mockBehavior\" />.").AppendLine();
			sb.Append("\t/// </summary>").AppendLine();
			sb.Append("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>")
				.AppendLine();
			for (int i = 2; i <= numberOfArguments; i++)
			{
				sb.Append("\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.Append("\t/// <remarks>").AppendLine();
			sb.Append(
					"\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.")
				.AppendLine();
			sb.Append("\t/// </remarks>").AppendLine();
			sb.Append("\tpublic static Mock<T, ").Append(types).Append("> Create<T, ").Append(types)
				.Append(">(BaseClass.ConstructorParameters constructorParameters, MockBehavior mockBehavior)")
				.AppendLine();
			sb.Append("\t{").AppendLine();
			sb.Append("\t\treturn new MockGenerator().Get<T, ").Append(types)
				.Append(">(constructorParameters, mockBehavior)").AppendLine();
			sb.Append("\t\t\t?? throw new MockException(\"Could not generate Mock<T, ").Append(types)
				.Append(">. Did the source generator run correctly?\");").AppendLine();
			sb.Append("\t}").AppendLine();
			sb.AppendLine();
		}

		sb.AppendLine("/// <summary>");
		sb.AppendLine("///     A mock factory to create mocks with a common behavior.");
		sb.AppendLine("/// </summary>");
		sb.AppendLine("public partial class Factory");
		sb.AppendLine("{");
		sb.AppendLine("\tprivate MockBehavior _behavior;");
		sb.AppendLine();
		sb.AppendLine("\t/// <inheritdoc cref=\"MockFactory\" />");
		sb.AppendLine("\tpublic Factory(MockBehavior behavior)");
		sb.AppendLine("\t{");
		sb.AppendLine("\t\t_behavior = behavior;");
		sb.AppendLine("\t}");
		sb.AppendLine();
		sb.AppendLine("\t/// <summary>");
		sb.AppendLine(
			"\t///     Create a new mock for <typeparamref name=\"T\" />.");
		sb.AppendLine("\t/// </summary>");
		sb.AppendLine("\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
		sb.AppendLine("\t/// <remarks>");
		sb.AppendLine(
			"\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.");
		sb.AppendLine("\t/// </remarks>");
		sb.AppendLine("\tpublic Mock<T> Create<T>(BaseClass.ConstructorParameters? constructorParameters = null)");
		sb.AppendLine("\t{");
		sb.Append("\t\treturn new MockGenerator().Get<T>(constructorParameters, _behavior)").AppendLine();
		sb.Append("\t\t\t?? throw new MockException(\"Could not generate Mock<T>. Did the source generator run correctly?\");").AppendLine();
		sb.AppendLine("\t}");
		for (int numberOfArguments = 1; numberOfArguments < maxNumberOfArguments; numberOfArguments++)
		{
			sb.AppendLine();
			string types = string.Join(", ", Enumerable.Range(2, numberOfArguments).Select(n => $"T{n}"));
			sb.AppendLine("\t/// <summary>");
			sb.Append("\t///     Create a new mock for <typeparamref name=\"T\" /> that also implements interface ")
				.Append(string.Join(", ",
					Enumerable.Range(2, numberOfArguments - 1).Select(n => $"<typeparamref name=\"T{n}\" />")))
				.Append(" and <typeparamref name=\"T").Append(numberOfArguments).Append("\" />.").AppendLine();
			sb.AppendLine("\t/// </summary>");
			sb.AppendLine(
				"\t/// <typeparam name=\"T\">Type to mock, which can be an interface or a class.</typeparam>");
			for (int i = 2; i <= numberOfArguments; i++)
			{
				sb.Append("\t/// <typeparam name=\"T").Append(i)
					.Append("\">Additional interface that is implemented by the mock.</typeparam>").AppendLine();
			}

			sb.Append("\t/// <remarks>").AppendLine();
			sb.Append(
					"\t///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.")
				.AppendLine();
			sb.Append("\t/// </remarks>").AppendLine();
			sb.Append("\tpublic Mock<T, ").Append(types).Append("> Create<T, ").Append(types)
				.Append(">(BaseClass.ConstructorParameters? constructorParameters = null)").AppendLine();
			sb.Append("\t{").AppendLine();
			sb.Append("\t\treturn new MockGenerator().Get<T, ").Append(types)
				.Append(">(constructorParameters, _behavior)").AppendLine();
			sb.Append("\t\t\t?? throw new MockException(\"Could not generate Mock<T, ").Append(types)
				.Append(">. Did the source generator run correctly?\");").AppendLine();
			sb.Append("\t}").AppendLine();
		}
		sb.AppendLine("}");
		sb.AppendLine();

		sb.Append("\tprivate partial class MockGenerator").AppendLine();
		sb.Append("\t{").AppendLine();
		sb.Append("\t\tprivate object? _value;").AppendLine();
		sb.Append(
				"\t\tpartial void Generate(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior, params Type[] types);")
			.AppendLine();
		sb.Append(
				"\t\tpublic Mock<T>? Get<T>(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior)")
			.AppendLine();
		sb.Append("\t\t{").AppendLine();
		sb.Append("\t\t\tGenerate(constructorParameters, mockBehavior, typeof(T));").AppendLine();
		sb.Append("\t\t\treturn _value as Mock<T>;").AppendLine();
		sb.Append("\t\t}").AppendLine();
		for (int i = 1; i < maxNumberOfArguments; i++)
		{
			string types = string.Join(", ", Enumerable.Range(2, i).Select(n => $"T{n}"));
			sb.Append("\t\tpublic Mock<T, ").Append(types).Append(">? Get<T, ").Append(types)
				.Append(">(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior)")
				.AppendLine();
			sb.Append("\t\t{").AppendLine();
			sb.Append("\t\t\tGenerate(constructorParameters, mockBehavior, typeof(T), ")
				.Append(string.Join(", ", Enumerable.Range(2, i).Select(n => $"typeof(T{n})"))).Append(");")
				.AppendLine();
			sb.Append("\t\t\treturn _value as Mock<T, ").Append(types).Append(">;").AppendLine();
			sb.Append("\t\t}").AppendLine();
		}

		sb.Append("\t}").AppendLine();
		sb.Append("}").AppendLine();
		sb.Append("#nullable disable").AppendLine();

		return sb.ToString();
	}

	internal static string ToVisibilityString(this Accessibility accessibility)
		=> accessibility switch
		{
			Accessibility.Private => "private",
			Accessibility.Protected => "protected",
			Accessibility.Internal => "internal",
			Accessibility.ProtectedOrInternal => "protected",
			Accessibility.Public => "public",
			Accessibility.ProtectedAndInternal => "private protected",
			_ => throw new ArgumentOutOfRangeException(nameof(accessibility), accessibility, null),
		};

	internal static string GetString(this RefKind refKind)
		=> refKind switch
		{
			RefKind.None => "",
			RefKind.In => "in ",
			RefKind.Out => "out ",
			RefKind.Ref => "ref ",
			RefKind.RefReadOnlyParameter => "ref readonly ",
			_ => "",
		};
}
